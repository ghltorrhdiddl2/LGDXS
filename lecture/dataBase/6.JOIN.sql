-- 6. JOIN
-- 직원 아이디가 100인 직원의 부서이름 출력
SELECT d.DEPARTMENT_NAME FROM employees e JOIN departments d ON e.DEPARTMENT_ID=d.DEPARTMENT_ID
WHERE e.EMPLOYEE_ID=100;

-- JOIN : 여러개의 테이블을 연결해서 사용
-- 필요한 데이터가 2개 이상의 테이블에 나눠져 있을 때 한 번에 조회하는 방법
SELECT E.EMPLOYEE_ID, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM employees E, departments D
WHERE E.DEPARTMENT_ID=D.DEPARTMENT_ID AND E.EMPLOYEE_ID=100;

-- FROM절
-- 테이블 여러개 사용가능+별칭 사용 가능
-- 별칭을 사용한 이후에는 별칭만 사용 가능! (SELECT, WHERE 절 등에서)
-- 테이블이 여러개인 경우, 어떤 테이블의 컬럼인지 정확하게 명시

-- CROSS JOIN(카티션곱) : 조인조건을 걸지 않고 모든 데이터를 곱해서 출력하는 조인방법
-- 직원ID와 부서ID, 부서NAME을 출력하세요
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D;

-- INNER JOIN
-- WHERE절을 사용한 ORACLE 문법
-- 직원ID와 부서ID, 부서NAME을 출력하세요
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY 1;


-- ANSI문법
-- SELECT
-- FROM 테이블A INNER JOIN 테이블B
-- ON 조인조건;
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY 1;

-- 실습
SELECT EMPLOYEE_ID,E.JOB_ID, JOB_TITLE FROM employees E, jobs J
WHERE e.job_id=j.job_id
ORDER BY 1;

SELECT EMPLOYEE_ID,E.JOB_ID, JOB_TITLE FROM employees E INNER JOIN jobs J 
ON e.job_id=j.job_id
ORDER BY 1;

-- 각 직원의 직무 이름을 출력
SELECT EMPLOYEE_ID, first_name, job_title FROM employees e, jobs j
where e.job_id=j.job_id
order by 1;

SELECT EMPLOYEE_ID, first_name, job_title FROM employees e inner join jobs j
on e.job_id=j.job_id
order by 1;


-- OUTER JOIN
-- 1. LEFT OUTER JOIN : A테이블에 남아있는 값 + 교집합(INNER JOIN)
-- 2. RIGHT OUTER JOIN: B테이블에 남아있는 값 + 교집합(INNER JOIN)
-- 3. FULL OUTER JOIN : A테이블에 남아있는 값 + 교집합(INNER JOIN) + B테이블에 남아있는 값

-- INNER JOIN 교집합 106개(부서에 속해있는 직원의 수)
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY 1;

-- LEFT OUTER JOIN 108개(106+부서에 속해있지 않은 직원 2명)
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY 1;

-- RIGHT OUTER JOIN 122개(106+직원이 속해있지 않은 부서 16개)
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY 1;

-- FULL OUTER JOIN 124개(106+2+16)
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E FULL OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY 1;

-- ORACLE문법 OUTER JOIN
-- OUTER JOIN을 하고 싶은 반대편 테이블에 (+)기호를 붙이기!
-- LEFT OUTER JOIN : 오른쪽 테이블에 (+) 기호
-- RIGHT OUTER JOIN : 왼쪽 테이블에 (+) 기호
-- FULL OUTER JOIN : UNION 연산자

-- INNER JOIN 교집합 106개(부서에 속해있는 직원의 수)
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY 1;

-- LEFT OUTER JOIN 108개(106+부서에 속해있지 않은 직원 2명)
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
ORDER BY 1;

-- RIGHT OUTER JOIN 122개(106+직원이 속해있지 않은 부서 16개)
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID
ORDER BY 1;

-- FULL OUTER JOIN 124개(106+2+16)
-- UNION 연산자 : 합집합(중복X)
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
UNION
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID
ORDER BY 1;

-- FULL OUTER JOIN
-- UNION ALL 연산자 : 합집합(중복0) -> 230개(108+122)
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
UNION ALL
SELECT EMPLOYEE_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID
ORDER BY 1;

-- 실습
-- 각 부서의 매니저 직원들을 출력
SELECT d.department_name, d.manager_id,e.EMPLOYEE_ID FROM employees E INNER JOIN departments D 
ON e.manager_id=d.manager_id; 

-- 문제1
SELECT J.JOB_TITLE JOB, SUM(E.SALARY) 급여
FROM JOBS J, EMPLOYEES E
WHERE J.JOB_ID=e.job_id AND J.JOB_TITLE NOT LIKE '%Representative%'
GROUP BY J.JOB_TITLE
having SUM(E.SALARY) > 30000
order by 2;

-- 문제2
SELECT D.DEPARTMENT_NAME AS 부서명, COUNT(E.EMPLOYEE_ID) AS 인원수 
FROM DEPARTMENTS D INNER JOIN EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE E.HIRE_DATE < '2005/01/01'
GROUP BY D.DEPARTMENT_NAME;

-- 문제3
SELECT D.DEPARTMENT_ID 부서번호, D.DEPARTMENT_NAME 부서명, COUNT(E.EMPLOYEE_ID) 인원수, MAX(E.salary) 최고급여,
MIN(E.salary) 최저급여, ROUND(AVG(E.salary)) 평균급여, SUM(E.salary) 급여총액
FROM DEPARTMENTS D JOIN EMPLOYEES E ON D.DEPARTMENT_ID=E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING COUNT(E.EMPLOYEE_ID)>=3
ORDER BY 3 DESC;

-- 실습
SELECT d.department_id,l.city,c.country_name FROM departments d 
inner join locations l on d.location_id=l.location_id
inner join countries c on l.country_id=c.country_id;